<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[直白解读vue]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%9B%B4%E7%99%BD%E8%A7%A3%E8%AF%BBvue%2F</url>
    <content type="text"><![CDATA[转自知乎： 最近在逛各大网站，论坛，以及像SegmentFault等编程问答社区，发现Vue.js异常火爆，重复性的提问和内容也很多，楼主自己也趁着这个大前端的热潮，着手学习了一段时间的Vue.js，目前用它正在做自己的结业项目。 在做的过程中也对Vue.js的官方文档以及其各种特性有了许多认识。作为一个之前以PHP+模版引擎为主的开发，从一个从未接触过除HTML+CSS+JavaScript+JQuery以外的前端技术的人到现在可以独立使用Vue.js以及各种附属的UI库来开发项目，我总结了一些知识和经验想与大家分享。 下面我就以问答的形式来分享吧。这里假设你仅仅只掌握了HTML+CSS+JavaScript，如果你对JQuery这个前端库，以及各种后端模版语言比如说PHP，JSP还有所了解并且使用过的话那就太好了。 ###1.Vue.js是什么？ Vue.js（读音 /vjuː/, 类似于 view是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。 这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？ 不要担心，如果你慢慢看完这里面的所有问答，一定会对前面那些可能你从未听说过的专业术语有一种恍然大悟的感觉。 ###32.Vue.js到底是什么？想必现在能看到我这篇文章的人，都是用着APP或者网页版知乎在阅读把。Vue.js就是一个用于搭建类似于网页版知乎这种表单项繁多，且内容需要根据用户的操作进行修改的网页版应用。 ####3.单页应用程序（SPA）顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。 ###34.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。 现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。 我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。 Vue 的核心库只关注视图层我们为什么要把视图层抽取出来并且单独去关注它呢？ 因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？ 你是否还记得你当初写JQuery的时候，有写过$(‘#xxx’).parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么$(‘#xxx’).parent().parent().parent()可能就会变成$(‘#xxx’).parent().parent().parent().parent().parent()了。 这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。 当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。 这个时候如果你学过Vue.js，那么这些抱怨将不复存在。 ###35.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。 可是这些名词都是啥？ ####6.响应式的数据绑定这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue.js测试 - 代码之美专栏&lt;/title&gt; &lt;!-- author:昌维 代码之美 https://zhuanlan.zhihu.com/codes --&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" name="" value="" placeholder="在这里输入文字，下面会跟着变化" v-model="message"&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 是不是会发现一个很神奇的现象，文本框里面输入的文字和后面的p标签中的内容一起变化？ 换句话说，p标签里面通过这个写法与input标签中的value绑定在了一起，其中变化，另外一个和它绑定的数据就跟着变化。 结合标题来说，就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。 ####7.组件化开发还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说PHP的Smarty或者Java的JSP等等。但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。 在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。 Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。 ####8.Virtual DOM现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。 而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。 对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。 ####9.我到底该怎么用Vue.js做单页应用开发？说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？ 前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？ 我的建议是，先把介绍 - vue.js官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。 然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。 最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。 ####10.在前面你提到过好几次ECMAScript，这是啥？ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？ 没错你猜对了，他们之间还真有着很深的联系。 引用阮一峰老师的话：（ECMAScript 6入门） 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。 该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 而ECMAScript6就是新一代的JavaScript语言。 这里也强烈推荐大家学习ECMAScript6的时候参考这本书ECMAScript 6入门 ####11.我在学习Vue.js的时候老是听到Webpack，这是啥？Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。 ####12.为什么要用Webpack前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？ 还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。 前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6 to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。 开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中 当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。 ####13.NPM和Node.js又是什么？它们是什么关系？首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。 NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过 npm install xxx包名称的方式引入它，比如说 npm install vue就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。 至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。 前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。 如果你学过PHP的话，NPM就和PHP里面的Composer差不多。也和CentOS下的yum和Ubuntu下的apt-get差不多。 ####14.Vue-CLi又是啥？它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过 npm install vue-cli -g的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。 ####15.我该不该学Vue.js？现在Vue.js无论是发展势头还是作者支持还是很好的，而且它本身中文资料就比较多，教程也很多，现在随随便便打开几个和前端开发有关的知乎专栏，基本上都能见到相关文章，社区也很活跃。 至于你该不该学，取决于你自己，如果你当前只是做做以内容展示为主的项目，或者就是成天用各种CMS建站仿站，并且以后都不打算更换更好的工作，那么可以暂时不用学。如果你开发的项目交互非常多，而且前后端开发都对前后端分离有很清楚的认识，那么可以大胆的学习，并且在实际项目中运用。 ####16.Vue.js怎么火起来的？关于这个问题，网上说法很多，我自己认为主要还是前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。 对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。 而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。 当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。 ####17.我在很多地方还看到Vuex和Vue-route，它们又是什么？Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。 Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。 要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。 ####18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。 在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。 vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。 ####19.我该学Vue.js2.0还是1.0呢？现在很多框架和语言都是学新不学旧（Python慢慢也变得如此），因此如果不是为了维护老旧项目，肯定推荐学Vue.js2.0。而且学会了Vue.js2.0，再去学习Vue.js1.0也不是什么难事。 ####20.写Vue.js用什么开发工具和电脑呢？前端开发基本上不需要太高端的电脑都能胜任，现在这个时代是台电脑，装个编辑器都可以做前端开发的。 Vue.js的组件文件本质上还是普通的代码文件，所以各种编辑器配合一些语法检查插件就足够了。我自己用的是sublime text 3，安装一些插件之后可以实现.vue单文件组件高亮代码以及各种自动完成。Webstorm中也有类似插件，大家可以在网上各种教学文章的指导下配置好环境。 ####结语：可能包括我在内的很多人在看到Vue.js那神奇的双向绑定优雅写法都会有一种非常惊艳，而看到中文文档发布之后有种想立马学习的冲动。可惜大前端终究是大前端，如果一个对于前端各个方面没有深入认识就想着能一步登天，肯定对不起大前端的“大”字。原本看着只想学一个Vue.js，没想到顺带把ECMAScript6，Webpack配置，ESLint配置，bable配置，npm使用，node.js语法，以后vue全家桶中的vuex，vue-route等等等等都学了一遍。前段时间网上也流传出了一个职位叫做Webpack配置工程师，从这里也可以看出弄懂前端这个大杂烩确实不是那么容易。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端代码优化兼容小结]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%85%BC%E5%AE%B9%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[如何让页面加载速度更快呢？1、优化图片，包含大量图片的页面加载速度非常缓慢，这会耗费很多带宽资源 2、尽量减少或避免使用页内iframe框架，因为在打开一个页面的同时，浏览器实际上在同时访问多个页面，所有的iframe加载完后，你才能看到一个完整页面 3、在html代码的底部加载javascript操作，而非放在头部加载，页面执行是从上而下执行的，如果某个js加载耗时太长，这会影响到整个页面 4、合并资源文件、压缩文件 5、尽量减少HTTP的请求次数 6、缓存技术。访问量大的页面（如首页）生成静态页，常用的且变更不频繁的模块使用局部缓存，减少数据库查询次数 7、延迟显示可见区域外的内容 8、延长执行非必要脚本 9、尽量使用图片代替flase 10、避免阻塞 11、Gzip压缩 12、DNS读取]]></content>
  </entry>
  <entry>
    <title><![CDATA[细说新技术]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%BB%86%E8%AF%B4%E6%96%B0%E6%8E%A5%E8%A7%A6%E7%9A%84%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[GitGit，版本管理工具。用这个东西几个月了，没什么好说的，就是修改代码，提交代码，推送。 方便多人合作。这个自己可以看一下网上的教程，了解一下每个操作的概念。具体的还得在实际工作中，看下团队的需要，才能知道具体需要用到哪些。Less Less是一种动态样式语言,属于CSS预处理语言的一种，和Sass是一个意思。就是通过一些嵌套，mixin，变量等。编译出你需要的CSS。让你自己写的样式更少些。 例如： base.less 12345678910box&#123; @color1: red; @color2: blue; span&#123; background: @color1; &#125; a&#123; color: @color2; &#125;&#125; 编译后的CSS为 base.css123456#box span&#123;background: red; &#125;#box a &#123; color: blue; &#125; AngularAngularJs是MVVM的模式。Model,View,ViewModel。 就是Model的数据发生改变时，View层的表现也会同时发生变化。 View层的数据发生改变时，Model里的数据也会随之改变。 不需要写任何的事件操作。只需要绑定一下模型。 这个跟着看了一遍文档教程,跟着视频走了一遍,Demo写了一些。 requireJs RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。 可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址 模版引擎 handlebars.js template.js 这里的模版引擎仅仅是为了”不拼字符串”。具体的操作也没什么好说的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue基本配置和生命周期]]></title>
    <url>%2F2018%2F06%2F15%2FVue%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8BVue%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue的实例是Vue框架的入口，其实也就是前端的ViewModel，它包含了页面中的业务逻辑处理、数据模型等，当然它也有自己的一系列的生命周期的事件钩子，辅助我们进行对整个Vue实例生成、编译、挂着、销毁等过程进行js控制。 # 5.1. Vue实例初始化的选项配置对象详解前面我们已经用了很多次new Vue({…})的代码，而且Vue初始化的选项都已经用了data、methods、el、computedd等,估计您看到这里时，应该已经都明白了他们的作用，我们就详细讲解一下他们的使用情况。更详细的请参考官网内容 5.1.1. Vue实例的的data对象介绍Vue的实例的数据对象data 我们已经用了很多了，数据绑定离不开data里面的数据。也是Vue的核心属性。 它是Vue绑定数据到HTML标签的数据源泉，另外Vue框架会自动监视data里面的数据变化，自动更新数据到HTML标签上去。本质原理是：Vue会自动将data里面的数据进行递归抓换成getter和setter，然后就可以自动更新HTML标签了，当然用getter和setter所以老的浏览器Vue支持的不够好。 data对象的类型： 类型是Object或者Function。 如果是组件对象中，data必须是Function类型。【后面学了组件后就明白了，暂时对组件先放放。】 1234567891011121314151617181920212223实例：// 创建普通的Vue实例var vm = new Vue(&#123; data: data&#125;)// 组件定义【后面会详细讲的】// Vue.extend() 中 data 必须是函数var Component = Vue.extend(&#123; data: function () &#123; //这里必须是函数！！！！ return &#123; a: 1 &#125; &#125;&#125;) 5.1.2. Vue实例的computed介绍Vue的计算属性（computed)的属性会自动混入Vue的实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。这就很强大了，再计算属性中定义的函数里面可以直接使用指向了vue实例的this，异常方便的啊。 类型{ 键：函数}{ [key: string]: Function | { get: Function, set: Function } }当然，可以省略setter,如果省略了setter，那么值就可以是普通函数，但是必须有返回值。 官方的实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var vm = new Vue(&#123;data: &#123; a: 1 &#125;,computed: &#123; // 仅读取，值只须为函数 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125;&#125;&#125;)vm.aPlus // -&gt; 2vm.aPlus = 3vm.a // -&gt; 2vm.aDouble // -&gt; 45.1.3. methods类型: &#123; [key: string]: Function &#125; 详细:methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 123456789101112131415161718192021222324252627示例:var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 25.1.4. watch类型&#123; [key: string]: string | Function | Object &#125; 详细:一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 123456789101112131415161718192021222324252627282930313233343536373839示例:var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; // 监控a变量变化的时候，自动执行此函数 a: function (val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal) &#125;, // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;)vm.a = 2 // -&gt; new: 2, old: 1 //注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 参考综合案例:5.1.5. 设置el的详解类型 string | HTMLElement 限制： 只在由 new 创建的实例中遵守。 详细： 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标,也就是说Vue绑定数据到哪里去找。可以是CSS 选择器，也可以是一个HTMLElement实例。 在实例挂载之后(生命周期的内容后面会详细讲的奥)， 元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 // 几乎所有例子都用到这个，所以就不再赘述 1234567var app = new Vue(&#123; el: &apos;#app&apos;, ...&#125;); 5.2. Vue实例的生命周期Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们注册js方法，可以让我们达到控制整个过程的目的地，哇赛，如果你搞过Asp.Net WebForm的话，你会发现整个就是WebForm的翻版嘛哈哈。值得注意的是，在这些事件响应方法中的this直接指向的是vue的实例。 首先看看下面官网的一张生命周期的图，我做一下标注，看看整体的流程，后面我们上代码做一下效果。 Vue提供的可以注册的钩子都在上图片的红色框标注。 他们是： beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 接下来我们做一个例子，看一下Vue中所有的生命周期怎么用的。 再看一个综合的实战的例子，可能涉及到ajax和组件，不过先看一下vue的生命周期的例子的用法： import Axios from ‘axios’ // 这是一个轻量级的ajax库，import是es6模块导入的语法。 123456789101112131415161718192021222324252627282930313233343536373839export default &#123; // 这是一个vue的模块，后面讲奥。 name: &apos;app&apos;, components: &#123; &#125;, data: function () &#123; return &#123; list: [] &#125; &#125;, mounted: function () &#123; // 挂在完成后的生命周期钩子注册。 this.$nextTick(function () &#123; // 等待下一次更新完成后执行业务处理代码。 Axios.get(&apos;/api/menulist&apos;, &#123;// 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新 params: &#123; &#125; &#125;).then(function (res) &#123; this.list = res.data &#125;.bind(this)) &#125;) &#125;&#125; 5.3. Vue实例的全局配置这一块都是一些小的知识点，我就不赘述了，直接copy官网Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性： 123456789101112131415161718192021222324252627282930313233silent类型： boolean默认值： false用法：Vue.config.silent = true//取消 Vue 所有的日志与警告。optionMergeStrategies类型： &#123; [key: string]: Function &#125;默认值： &#123;&#125;用法：Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123;return child + 1&#125;const Profile = Vue.extend(&#123;_my_option: 1&#125;)// Profile.options._my_option = 2 //自定义合并策略的选项。 //合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。 devtools 类型： boolean 默认值： true (生产版为 false) 用法： // 务必在加载 Vue 之后，立即同步设置以下内容 1Vue.config.devtools = true //配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler 类型： Function 默认值： 默认抛出错误 用法： 12345Vue.config.errorHandler = function (err, vm) &#123;// handle error&#125; //指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 1234567//Sentry, an error tracking service, provides official integration using this option.ignoredElements类型: Array默认值: [] 用法: 123Vue.config.ignoredElements = [&apos;my-custom-web-component&apos;, &apos;another-web-component&apos; ] 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes 类型： { [key: string]: number | Array } 默认值： {} 用法： Vue.config.keyCodes = { v: 86, f1: 112, mediaPlayPause: 179, up: [38, 87] }api //给 v-on 自定义键位别名。 5.4. Vue的全局API Vue的全局API提供大量的功能，我这里就给大家罗列几个常用的结果，其他的还是参考官网. 5.4.1. Vue.nextTick 语法： Vue.nextTick( [callback, context] ) 参数： {Function} [callback] {Object} [context] 用法： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 // 修改数据 vm.msg = ‘Hello’ // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) 5.4.2. Vue.set 语法： Vue.set( object, key, value ) 参数： {Object} object {string} key {any} value 返回值： 设置的值. 用法： 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 5.4.3. Vue.compile 语法： Vue.compile( template ) 参数： {string} template 用法： //在render函数中编译模板字符串。只在独立构建时有效 var res = Vue.compile(‘ ‘)new Vue({ data: { msg: &apos;hello&apos; }, render: res.render, staticRenderFns: res.staticRenderFns }) 5.4.4. 全局API总结 其实还有几个其他的全局API，不打算在这里讲了，比如扩展组件Vue.extend 的用法、Vue.use加载插件、Vue.filter加载过滤器、Vue.directive自定义指令等 后面再讲其他Vue的知识点的时候，再加上这些，全局API其实就是Vue类型的静态方法，全局范围内都可以使用的，某些实例的方法本质也是调用了这些全局的，后面用到时候再说。 5.5. Vue实例与生命周期总结 Vue的实例封装的还是挺有艺术性的，很符合开发者的思维规范，它的生命周期也非常清晰，使用起来也非常方便。Vue确实一个好框架。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jsonp解析]]></title>
    <url>%2F2018%2F06%2F14%2F%E8%AF%A6%E8%A7%A3jsonp%2F</url>
    <content type="text"><![CDATA[什么是JSONP首先提一下JSON这个概念，JSON是一种轻量级的数据传输格式，被广泛应用于当前Web应用中。JSON格式数据的编码和解析基本在所有主流语言中都被实现，所以现在大部分前后端分离的架构都以JSON格式进行数据的传输。 那么JSONP是什么呢？首先抛出浏览器同源策略这个概念，为了保证用户访问的安全，现代浏览器使用了同源策略，即不允许访问非同源的页面，详细的概念大家可以自行百度。这里大家只要知道，在ajax中，不允许请求非同源的URL就可以了，比如www.a.com下的一个页面，其中的ajax请求是不允许访问www.b.com/c.php这样一个页面的。 JSONP就是用来解决跨域请求问题的，那么具体是怎么实现的呢？ JSONP原理ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 JSONP具体实现1.首先看下ajax中如果进行跨域请求会如何。前端代码在域www.practice.com下面，使用ajax发送了一个跨域的get请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonhandle(data)&#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; type : &quot;get&quot;, async: false, url : &quot;http://www.practice-zhao.com/student.php?id=1&quot;, type: &quot;json&quot;, success : function(data) &#123; jsonhandle(data); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;后端PHP代码放在域www.practice-zhao.com下，简单的输出一段json格式的数据jsonhandle(&#123; &quot;age&quot; : 15, &quot;name&quot;: &quot;John&quot;,&#125;)当访问前端代码http://www.practice.com/gojsonp/index.html 时 chrome报以下错误 这里写图片描述提示了不同源的URL禁止访问 2.下面使用JSONP，将前端代码中的ajax请求去掉，添加了一个script标签，标签的src指向了另一个域www.practice-zhao.com下的remote.js脚本 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonhandle(data)&#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.practice-zhao.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这里调用了跨域的remote.js脚本，remote.js代码如下：jsonhandle(&#123; &quot;age&quot; : 15, &quot;name&quot;: &quot;John&quot;,&#125;) 也就是这段远程的js代码执行了上面定义的函数，弹出了提示框这里写图片描述 3.将前端代码再进行修改，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonhandle(data)&#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; var url = &quot;http://www.practice-zhao.com/student.php?id=1&amp;callback=jsonhandle&quot;; var obj = $(&apos;&lt;script&gt;&lt;\/script&gt;&apos;); obj.attr(&quot;src&quot;,url); $(&quot;body&quot;).append(obj); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这里动态的添加了一个script标签，src指向跨域的一个php脚本，并且将上面的js函数名作为callback参数传入，那么我们看下PHP代码怎么写的：&lt;?php$data = array( &apos;age&apos; =&gt; 20, &apos;name&apos; =&gt; &apos;张三&apos;,);$callback = $_GET[&apos;callback&apos;];echo $callback.&quot;(&quot;.json_encode($data).&quot;)&quot;;return;PHP代码返回了一段JS语句，即jsonhandle(&#123; &quot;age&quot; : 15, &quot;name&quot;: &quot;张三&quot;,&#125;) 此时访问页面时，动态添加了一个script标签，src指向PHP脚本，执行返回的JS代码，成功弹出提示框。所以JSONP将访问跨域请求变成了执行远程JS代码，服务端不再返回JSON格式的数据，而是返回了一段将JSON数据作为传入参数的函数执行代码。 4.最后jQuery提供了方便使用JSONP的方式，代码如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; type : &quot;get&quot;, async: false, url : &quot;http://www.practice-zhao.com/student.php?id=1&quot;, dataType: &quot;jsonp&quot;, jsonp:&quot;callback&quot;, //请求php的参数名 jsonpCallback: &quot;jsonhandle&quot;,//要执行的回调函数 success : function(data) &#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[怎么开始创建运行博客]]></title>
    <url>%2F2018%2F06%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始Create a new post 创建一个项目1$ hexo new "My New Post" More info: Writing Run server 运行1$ hexo server More info: Server Generate static files 生成静态文件1$ hexo generate More info: Generating Deploy to remote sites 部署到远程站点1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
