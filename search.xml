<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F06%2F21%2F%60string%60%20%E6%98%AF%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[string 是模板字符串，ES2015新增的符号。 12var x = &apos;a&apos;, y = &apos;b&apos;;var z = `$&#123;x,y&#125;`; //&apos;b&apos; 模板字符串里面${var}是变量的占位符。x,y 逗号运算符是返回符号右边的值，这里面等于y。 其实是这样的 ${}里边 依旧是js，外边也是js 什么场景使用最好呢，还记得字符串拼接吗没错，++++例如：12var a = 1; console.log(&apos;一共有&apos;+a+&apos;个鸡蛋！&apos;)那么现在你只要console.log(`一共有$&#123;a&#125;个鸡蛋！`)]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue基本配置和生命周期]]></title>
    <url>%2F2018%2F06%2F15%2FVue%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8BVue%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue的实例是Vue框架的入口，其实也就是前端的ViewModel，它包含了页面中的业务逻辑处理、数据模型等，当然它也有自己的一系列的生命周期的事件钩子，辅助我们进行对整个Vue实例生成、编译、挂着、销毁等过程进行js控制。 # 5.1. Vue实例初始化的选项配置对象详解前面我们已经用了很多次new Vue({…})的代码，而且Vue初始化的选项都已经用了data、methods、el、computedd等,估计您看到这里时，应该已经都明白了他们的作用，我们就详细讲解一下他们的使用情况。更详细的请参考官网内容 5.1.1. Vue实例的的data对象介绍Vue的实例的数据对象data 我们已经用了很多了，数据绑定离不开data里面的数据。也是Vue的核心属性。 它是Vue绑定数据到HTML标签的数据源泉，另外Vue框架会自动监视data里面的数据变化，自动更新数据到HTML标签上去。本质原理是：Vue会自动将data里面的数据进行递归抓换成getter和setter，然后就可以自动更新HTML标签了，当然用getter和setter所以老的浏览器Vue支持的不够好。 data对象的类型： 类型是Object或者Function。 如果是组件对象中，data必须是Function类型。【后面学了组件后就明白了，暂时对组件先放放。】 1234567891011121314151617181920212223实例：// 创建普通的Vue实例var vm = new Vue(&#123; data: data&#125;)// 组件定义【后面会详细讲的】// Vue.extend() 中 data 必须是函数var Component = Vue.extend(&#123; data: function () &#123; //这里必须是函数！！！！ return &#123; a: 1 &#125; &#125;&#125;) 5.1.2. Vue实例的computed介绍Vue的计算属性（computed)的属性会自动混入Vue的实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。这就很强大了，再计算属性中定义的函数里面可以直接使用指向了vue实例的this，异常方便的啊。 类型{ 键：函数}{ [key: string]: Function | { get: Function, set: Function } }当然，可以省略setter,如果省略了setter，那么值就可以是普通函数，但是必须有返回值。 官方的实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var vm = new Vue(&#123;data: &#123; a: 1 &#125;,computed: &#123; // 仅读取，值只须为函数 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125;&#125;&#125;)vm.aPlus // -&gt; 2vm.aPlus = 3vm.a // -&gt; 2vm.aDouble // -&gt; 45.1.3. methods类型: &#123; [key: string]: Function &#125; 详细:methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 123456789101112131415161718192021222324252627示例:var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 25.1.4. watch类型&#123; [key: string]: string | Function | Object &#125; 详细:一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 123456789101112131415161718192021222324252627282930313233343536373839示例:var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; // 监控a变量变化的时候，自动执行此函数 a: function (val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal) &#125;, // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;)vm.a = 2 // -&gt; new: 2, old: 1 //注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 参考综合案例:5.1.5. 设置el的详解类型 string | HTMLElement 限制： 只在由 new 创建的实例中遵守。 详细： 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标,也就是说Vue绑定数据到哪里去找。可以是CSS 选择器，也可以是一个HTMLElement实例。 在实例挂载之后(生命周期的内容后面会详细讲的奥)， 元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 // 几乎所有例子都用到这个，所以就不再赘述 1234567var app = new Vue(&#123; el: &apos;#app&apos;, ...&#125;); 5.2. Vue实例的生命周期Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们注册js方法，可以让我们达到控制整个过程的目的地，哇赛，如果你搞过Asp.Net WebForm的话，你会发现整个就是WebForm的翻版嘛哈哈。值得注意的是，在这些事件响应方法中的this直接指向的是vue的实例。 首先看看下面官网的一张生命周期的图，我做一下标注，看看整体的流程，后面我们上代码做一下效果。 Vue提供的可以注册的钩子都在上图片的红色框标注。 他们是： beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 接下来我们做一个例子，看一下Vue中所有的生命周期怎么用的。 再看一个综合的实战的例子，可能涉及到ajax和组件，不过先看一下vue的生命周期的例子的用法： import Axios from ‘axios’ // 这是一个轻量级的ajax库，import是es6模块导入的语法。 123456789101112131415161718192021222324252627282930313233343536373839export default &#123; // 这是一个vue的模块，后面讲奥。 name: &apos;app&apos;, components: &#123; &#125;, data: function () &#123; return &#123; list: [] &#125; &#125;, mounted: function () &#123; // 挂在完成后的生命周期钩子注册。 this.$nextTick(function () &#123; // 等待下一次更新完成后执行业务处理代码。 Axios.get(&apos;/api/menulist&apos;, &#123;// 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新 params: &#123; &#125; &#125;).then(function (res) &#123; this.list = res.data &#125;.bind(this)) &#125;) &#125;&#125; 5.3. Vue实例的全局配置这一块都是一些小的知识点，我就不赘述了，直接copy官网Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性： 123456789101112131415161718192021222324252627282930313233silent类型： boolean默认值： false用法：Vue.config.silent = true//取消 Vue 所有的日志与警告。optionMergeStrategies类型： &#123; [key: string]: Function &#125;默认值： &#123;&#125;用法：Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123;return child + 1&#125;const Profile = Vue.extend(&#123;_my_option: 1&#125;)// Profile.options._my_option = 2 //自定义合并策略的选项。 //合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。 devtools 类型： boolean 默认值： true (生产版为 false) 用法： // 务必在加载 Vue 之后，立即同步设置以下内容 1Vue.config.devtools = true //配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler 类型： Function 默认值： 默认抛出错误 用法： 12345Vue.config.errorHandler = function (err, vm) &#123;// handle error&#125; //指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 1234567//Sentry, an error tracking service, provides official integration using this option.ignoredElements类型: Array默认值: [] 用法: 123Vue.config.ignoredElements = [&apos;my-custom-web-component&apos;, &apos;another-web-component&apos; ] 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes 类型： { [key: string]: number | Array } 默认值： {} 用法： Vue.config.keyCodes = { v: 86, f1: 112, mediaPlayPause: 179, up: [38, 87] }api //给 v-on 自定义键位别名。 5.4. Vue的全局API Vue的全局API提供大量的功能，我这里就给大家罗列几个常用的结果，其他的还是参考官网. 5.4.1. Vue.nextTick 语法： Vue.nextTick( [callback, context] ) 参数： {Function} [callback] {Object} [context] 用法： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 // 修改数据 vm.msg = ‘Hello’ // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) 5.4.2. Vue.set 语法： Vue.set( object, key, value ) 参数： {Object} object {string} key {any} value 返回值： 设置的值. 用法： 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 5.4.3. Vue.compile 语法： Vue.compile( template ) 参数： {string} template 用法： //在render函数中编译模板字符串。只在独立构建时有效 var res = Vue.compile(‘ ‘)new Vue({ data: { msg: &apos;hello&apos; }, render: res.render, staticRenderFns: res.staticRenderFns }) 5.4.4. 全局API总结 其实还有几个其他的全局API，不打算在这里讲了，比如扩展组件Vue.extend 的用法、Vue.use加载插件、Vue.filter加载过滤器、Vue.directive自定义指令等 后面再讲其他Vue的知识点的时候，再加上这些，全局API其实就是Vue类型的静态方法，全局范围内都可以使用的，某些实例的方法本质也是调用了这些全局的，后面用到时候再说。 5.5. Vue实例与生命周期总结 Vue的实例封装的还是挺有艺术性的，很符合开发者的思维规范，它的生命周期也非常清晰，使用起来也非常方便。Vue确实一个好框架。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jsonp解析]]></title>
    <url>%2F2018%2F06%2F14%2F%E8%AF%A6%E8%A7%A3jsonp%2F</url>
    <content type="text"><![CDATA[什么是JSONP首先提一下JSON这个概念，JSON是一种轻量级的数据传输格式，被广泛应用于当前Web应用中。JSON格式数据的编码和解析基本在所有主流语言中都被实现，所以现在大部分前后端分离的架构都以JSON格式进行数据的传输。 那么JSONP是什么呢？首先抛出浏览器同源策略这个概念，为了保证用户访问的安全，现代浏览器使用了同源策略，即不允许访问非同源的页面，详细的概念大家可以自行百度。这里大家只要知道，在ajax中，不允许请求非同源的URL就可以了，比如www.a.com下的一个页面，其中的ajax请求是不允许访问www.b.com/c.php这样一个页面的。 JSONP就是用来解决跨域请求问题的，那么具体是怎么实现的呢？ JSONP原理ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 JSONP具体实现1.首先看下ajax中如果进行跨域请求会如何。前端代码在域www.practice.com下面，使用ajax发送了一个跨域的get请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonhandle(data)&#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; type : &quot;get&quot;, async: false, url : &quot;http://www.practice-zhao.com/student.php?id=1&quot;, type: &quot;json&quot;, success : function(data) &#123; jsonhandle(data); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;后端PHP代码放在域www.practice-zhao.com下，简单的输出一段json格式的数据jsonhandle(&#123; &quot;age&quot; : 15, &quot;name&quot;: &quot;John&quot;,&#125;)当访问前端代码http://www.practice.com/gojsonp/index.html 时 chrome报以下错误 这里写图片描述提示了不同源的URL禁止访问 2.下面使用JSONP，将前端代码中的ajax请求去掉，添加了一个script标签，标签的src指向了另一个域www.practice-zhao.com下的remote.js脚本 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonhandle(data)&#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.practice-zhao.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这里调用了跨域的remote.js脚本，remote.js代码如下：jsonhandle(&#123; &quot;age&quot; : 15, &quot;name&quot;: &quot;John&quot;,&#125;) 也就是这段远程的js代码执行了上面定义的函数，弹出了提示框这里写图片描述 3.将前端代码再进行修改，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonhandle(data)&#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; var url = &quot;http://www.practice-zhao.com/student.php?id=1&amp;callback=jsonhandle&quot;; var obj = $(&apos;&lt;script&gt;&lt;\/script&gt;&apos;); obj.attr(&quot;src&quot;,url); $(&quot;body&quot;).append(obj); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这里动态的添加了一个script标签，src指向跨域的一个php脚本，并且将上面的js函数名作为callback参数传入，那么我们看下PHP代码怎么写的：&lt;?php$data = array( &apos;age&apos; =&gt; 20, &apos;name&apos; =&gt; &apos;张三&apos;,);$callback = $_GET[&apos;callback&apos;];echo $callback.&quot;(&quot;.json_encode($data).&quot;)&quot;;return;PHP代码返回了一段JS语句，即jsonhandle(&#123; &quot;age&quot; : 15, &quot;name&quot;: &quot;张三&quot;,&#125;) 此时访问页面时，动态添加了一个script标签，src指向PHP脚本，执行返回的JS代码，成功弹出提示框。所以JSONP将访问跨域请求变成了执行远程JS代码，服务端不再返回JSON格式的数据，而是返回了一段将JSON数据作为传入参数的函数执行代码。 4.最后jQuery提供了方便使用JSONP的方式，代码如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; type : &quot;get&quot;, async: false, url : &quot;http://www.practice-zhao.com/student.php?id=1&quot;, dataType: &quot;jsonp&quot;, jsonp:&quot;callback&quot;, //请求php的参数名 jsonpCallback: &quot;jsonhandle&quot;,//要执行的回调函数 success : function(data) &#123; alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[怎么开始创建运行博客]]></title>
    <url>%2F2018%2F06%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始Create a new post 创建一个项目1$ hexo new "My New Post" More info: Writing Run server 运行1$ hexo server More info: Server Generate static files 生成静态文件1$ hexo generate More info: Generating Deploy to remote sites 部署到远程站点1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
